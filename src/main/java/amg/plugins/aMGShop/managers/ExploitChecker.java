package amg.plugins.aMGShop.managers;

import amg.plugins.aMGShop.AMGShop;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.Recipe;
import org.bukkit.inventory.ShapedRecipe;
import org.bukkit.inventory.ShapelessRecipe;
import org.bukkit.inventory.FurnaceRecipe;
import org.bukkit.inventory.BlastingRecipe;
import org.bukkit.inventory.CampfireRecipe;
import org.bukkit.inventory.SmokingRecipe;
import org.bukkit.inventory.StonecuttingRecipe;
import org.bukkit.inventory.SmithingRecipe;
import org.bukkit.inventory.RecipeChoice;

import java.util.*;
import java.util.logging.Level;

public class ExploitChecker {
    private final AMGShop plugin;
    private final Map<Material, List<CraftingExploit>> potentialExploits;
    private final Map<Material, Double> materialBuyPrices;
    private final Map<Material, Double> materialSellPrices;

    public ExploitChecker(AMGShop plugin) {
        this.plugin = plugin;
        this.potentialExploits = new HashMap<>();
        this.materialBuyPrices = new HashMap<>();
        this.materialSellPrices = new HashMap<>();
    }

    public void checkForExploits() {
        // Clear previous data
        potentialExploits.clear();
        materialBuyPrices.clear();
        materialSellPrices.clear();

        // Load all material prices from shop
        loadMaterialPrices();

        // Check all recipes
        Iterator<Recipe> recipeIterator = Bukkit.recipeIterator();
        while (recipeIterator.hasNext()) {
            try {
                Recipe recipe = recipeIterator.next();
                checkRecipe(recipe);
            } catch (Exception e) {
                plugin.getLogger().log(Level.WARNING, "Error checking recipe for exploits", e);
            }
        }

        // Log found exploits
        logExploits();
    }

    private void loadMaterialPrices() {
        Map<String, Map<String, ShopManager.ShopItem>> categories = plugin.getShopManager().getCategories();
        
        for (Map.Entry<String, Map<String, ShopManager.ShopItem>> category : categories.entrySet()) {
            for (Map.Entry<String, ShopManager.ShopItem> item : category.getValue().entrySet()) {
                Material material = item.getValue().getMaterial();
                String categoryId = category.getKey();
                String itemId = item.getKey();

                double buyPrice = plugin.getShopManager().calculateBuyPrice(categoryId, itemId, 1);
                double sellPrice = plugin.getShopManager().calculateSellPrice(categoryId, itemId, 1);

                materialBuyPrices.put(material, buyPrice);
                materialSellPrices.put(material, sellPrice);
            }
        }
    }

    private void checkRecipe(Recipe recipe) {
        ItemStack result = recipe.getResult();
        Material resultMaterial = result.getType();
        
        // Skip if result item is not in shop
        if (!materialSellPrices.containsKey(resultMaterial)) {
            return;
        }

        Map<Material, Integer> ingredients = new HashMap<>();
        
        // Get ingredients based on recipe type
        if (recipe instanceof ShapedRecipe shapedRecipe) {
            String[] shape = shapedRecipe.getShape();
            Map<Character, RecipeChoice> choiceMap = shapedRecipe.getChoiceMap();
            
            for (String row : shape) {
                for (char c : row.toCharArray()) {
                    RecipeChoice choice = choiceMap.get(c);
                    if (choice instanceof RecipeChoice.MaterialChoice materialChoice) {
                        // Use the first material choice as the ingredient
                        if (!materialChoice.getChoices().isEmpty()) {
                            ingredients.merge(materialChoice.getChoices().get(0), 1, Integer::sum);
                        }
                    }
                }
            }
        } else if (recipe instanceof ShapelessRecipe shapelessRecipe) {
            for (RecipeChoice choice : shapelessRecipe.getChoiceList()) {
                if (choice instanceof RecipeChoice.MaterialChoice materialChoice) {
                    // Use the first material choice as the ingredient
                    if (!materialChoice.getChoices().isEmpty()) {
                        ingredients.merge(materialChoice.getChoices().get(0), 1, Integer::sum);
                    }
                }
            }
        } else if (recipe instanceof FurnaceRecipe furnaceRecipe) {
            handleCookingRecipeInput(furnaceRecipe.getInputChoice(), ingredients);
        } else if (recipe instanceof BlastingRecipe blastingRecipe) {
            handleCookingRecipeInput(blastingRecipe.getInputChoice(), ingredients);
        } else if (recipe instanceof CampfireRecipe campfireRecipe) {
            handleCookingRecipeInput(campfireRecipe.getInputChoice(), ingredients);
        } else if (recipe instanceof SmokingRecipe smokingRecipe) {
            handleCookingRecipeInput(smokingRecipe.getInputChoice(), ingredients);
        } else if (recipe instanceof StonecuttingRecipe stonecuttingRecipe) {
            handleCookingRecipeInput(stonecuttingRecipe.getInputChoice(), ingredients);
        } else if (recipe instanceof SmithingRecipe smithingRecipe) {
            RecipeChoice.MaterialChoice baseChoice = (RecipeChoice.MaterialChoice) smithingRecipe.getBase();
            RecipeChoice.MaterialChoice additionChoice = (RecipeChoice.MaterialChoice) smithingRecipe.getAddition();
            
            if (!baseChoice.getChoices().isEmpty()) {
                ingredients.put(baseChoice.getChoices().get(0), 1);
            }
            if (!additionChoice.getChoices().isEmpty()) {
                ingredients.put(additionChoice.getChoices().get(0), 1);
            }
        }

        // Calculate costs
        double totalBuyCost = 0.0;
        boolean allIngredientsInShop = true;

        for (Map.Entry<Material, Integer> entry : ingredients.entrySet()) {
            Material material = entry.getKey();
            int amount = entry.getValue();

            if (!materialBuyPrices.containsKey(material)) {
                allIngredientsInShop = false;
                break;
            }

            totalBuyCost += materialBuyPrices.get(material) * amount;
        }

        // Skip if not all ingredients are available in shop
        if (!allIngredientsInShop) {
            return;
        }

        double resultSellPrice = materialSellPrices.get(resultMaterial) * result.getAmount();
        double profit = resultSellPrice - totalBuyCost;

        // If profit is positive (with a small threshold for floating-point errors)
        if (profit > 0.01) {
            CraftingExploit exploit = new CraftingExploit(
                recipe,
                ingredients,
                totalBuyCost,
                resultSellPrice,
                profit
            );

            potentialExploits.computeIfAbsent(resultMaterial, k -> new ArrayList<>()).add(exploit);
        }
    }

    private void handleCookingRecipeInput(RecipeChoice choice, Map<Material, Integer> ingredients) {
        if (choice instanceof RecipeChoice.MaterialChoice materialChoice) {
            if (!materialChoice.getChoices().isEmpty()) {
                ingredients.put(materialChoice.getChoices().get(0), 1);
            }
        }
    }

    private void logExploits() {
        if (potentialExploits.isEmpty()) {
            plugin.getLogger().info("No crafting exploits found!");
            return;
        }

        plugin.getLogger().warning("Found potential crafting exploits:");
        for (Map.Entry<Material, List<CraftingExploit>> entry : potentialExploits.entrySet()) {
            Material resultMaterial = entry.getKey();
            List<CraftingExploit> exploits = entry.getValue();

            for (CraftingExploit exploit : exploits) {
                StringBuilder message = new StringBuilder();
                message.append("\nResult: ").append(resultMaterial.name());
                message.append("\nIngredients:");
                
                for (Map.Entry<Material, Integer> ingredient : exploit.ingredients().entrySet()) {
                    message.append("\n  - ").append(ingredient.getValue()).append("x ")
                           .append(ingredient.getKey().name())
                           .append(" ($").append(String.format("%.2f", materialBuyPrices.get(ingredient.getKey())))
                           .append(" each)");
                }
                
                message.append("\nTotal Cost: $").append(String.format("%.2f", exploit.totalCost()));
                message.append("\nSell Price: $").append(String.format("%.2f", exploit.sellPrice()));
                message.append("\nProfit: $").append(String.format("%.2f", exploit.profit()));
                message.append("\n");

                plugin.getLogger().warning(message.toString());
            }
        }
    }

    public Map<Material, List<CraftingExploit>> getPotentialExploits() {
        return Collections.unmodifiableMap(potentialExploits);
    }

    public record CraftingExploit(
        Recipe recipe,
        Map<Material, Integer> ingredients,
        double totalCost,
        double sellPrice,
        double profit
    ) {}
}